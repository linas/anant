
          Anant  -- Algorithmic 'n Analytic Number Theory
          -----------------------------------------------
                          Version 0.2
                   Linas Vepstas December 2010
                    linasvepstas@gmail.com


This project contains ad-hoc implementations of assorted analytic
functions of interest in number theory, including the gamma function,
the Riemann zeta function, the polylogarithm, and the Minkowski 
question mark function. The implementation uses the Gnu Multi-Precision
library (GMP) to perform all low-level operations.  The code herein
is licensed under the terms of the Gnu GPLv3 license.

This project is *NOT* meant to be a replacement for other, more
established multi-precision systems, such as PARI/GP.  It is meant to 
be a staging area for implementations of functions that have not (yet)
received much attention in the more established packages. Users are
strongly encouraged to port the contents of this package to other
systems.

This package has its origins as a collection of tools & utilities for 
the benefit of the author.  As such, it was never really intended for
public consumption, and thus, will not have the usual amenities of
established projects, such as clear documentation, a website, unit 
test cases, or even a robust build system.  Caveat Emptor!

Precision
---------
Most of the algorithms deal with precision issues in a fairly ad-hoc
kind of way.  Many/most routines require an argument specifying the 
number of decimal places of desired precision, and will typically 
return answers that are accurate from about 90% to 100% of the specified
precision. However, many of the algorithms use internal, intermediate 
results that need to be maintained at a higher level of precision than
the "desired" precision. Thus, correct usage requires that the user
specify an mpf_set_default_prec() that is 10% to 50% larger than the
desired precision of the results.  The proper amount to use is up to
you to figure out!  A reasonable rule-of-thumb seems to be to use 
mpf_set_default_prec(5*desired_decimal_places).


Example Usage
-------------
The example below shows an example of how to use the functions
in this library.

      // Standard include headers
      #include <gmp.h>
      #include <stdio.h>
      #include "mp-polylog.h"
      #include "mp-misc.h"
      
      int main()
      {
         cpx_t plog, ess, zee;
         int nbits;
         int decimal_prec;
      
         // decimal_prec is the number of decimal places of desired
         // precision.
         //
         // 3.3 is equal to log_2(10), and is used to convert decimal
         // places to number of binary bits.
         //
         // The +600 adds some extra "padding precision" for 
         // intermediate calculations. Most algorithms require some
         // fair amount of additional bits of precision to be used in
         // computing intermediate results.  The precise amount needed
         // is somewhat ad-hoc, and not well-characterized for the
         // different functions; typically, an extra 20% to 50% is
         // needed.
         //
         decimal_prec = 500;
         nbits = 3.3*decimal_prec + 600;
         mpf_set_default_prec (nbits);
         
         // Initialization
         cpx_init (plog);
         cpx_init (ess);
         cpx_init (zee);
      
         // Set values for which computation will be done.
         cpx_set_d(ess, 2.1, 0.0);
         cpx_set_d(zee, 0.5, 0.0);
      
         // Compute ... 
         int rc = cpx_polylog(plog, ess, zee, decimal_prec);
      
         // Check for error conditions
         if (0 != rc)
         {
         	printf("Error occured during computation! rc=%d\n", rc);
         	return 1;
         }
         cpx_prt("Answer is ", plog);
         printf("\n");
      
         return 0;
      }
      
